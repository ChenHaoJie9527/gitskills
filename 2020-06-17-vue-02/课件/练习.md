# 练习

[TOC]

## 问答题

1. el、template、render 定义视图的优先级是：
2. 使用 template 与 使用 render 定义视图，它们之间相同和不同的地方分别是：
3. 为什么推荐使用（可复用组件必须使用）函数定义data的原因是：
4. 哪些选项在定义数据过程需要注意命名冲突问题：
5. 为什么要在 v-for 中使用 :key 属性 ：



#### 1.el、template、render 定义视图的优先级:

答：render <= template <= el;

#### 2.使用 template 与 使用 render 定义视图，它们之间相同和不同的地方分别是：

答： 

#### 	相同点：

​	无论是template还是render，最终都会通过AST语法抽象树，将outhtml进行拆分重组，

​	通过算法解析得到的结果使用render函数进行调用，将语法抽象树里的东西进行配置，返回VNode对象，

​	最后通过diff算法将上一次VNode与即将更新的VNode进行比较，找出差异性进行渲染，基于重复利用，降低性	能损耗原则进行解析，得到的HTML渲染视图。

#### 	不同点：

​	在于使用template会有一个解析的过程，将解析后的template模板与挂载点容器的内容进行置换，将初始化之	后的数据挂载到组件实例上进行使用，最后J基于AST语法进行解析，通过render函数进行调用生成Vnode对            象，最后算法解析成HTML重新注入到容器中进行渲染。

  	而render函数，是在不适用template的前提下进行使用，会直接对接VNode对象，其实是通过调用render函数返回虚拟DOM对象进行解析生成HTML渲染，只是在步骤上简化了一些。

#### 3.为什么推荐使用（可复用组件必须使用）函数定义data的原因是： 

答：这里边涉及到多个引用问题，在Vue中只允许有且只有一个顶级组件，就好比金字塔里的顶端有且只有一层。data在顶级组件中是作为数据对象存在，通过初始化将里边的数据挂载到组件实例上，可以进行访问和控制。但是在使用一些可复用性组件中，通过使用Vue.computed进行初始化子组件，那么必然会将data作为数据数据对象进行挂载到模板上，这其实是基于vue底层做了处理，子组件初始化后，返回的是一个类，将类挂载到视图上的时候，其实是一个new 类的实例化过程，当多次调用同一个组件的时候，相当于new多个实例对象，但是实例对象的data被多个地方引用，当其中一个组件对data进行修改，那么其他组件也会发生变化，这是不愿意看到的。后来通过data函数式返回对象，可以很轻易的解决这个问题，因此，在底层原理中做了一件事，在初始化的时候回对data进行判断，如果是函数，那么直接调用自身，返回对象挂载到组件实例上。如果是对象，那么就会报错，不允许这种声明方式。

#### 4.哪些选项在定义数据过程需要注意命名冲突问题：

答：

​	data computed porps methods;

​	这是涉及到一个空间命名的问题，	data computed porps methods 中定义的数据初始化后会将挂载到组件实例上，方便访问和使用。但是当出现出现相同的命名后，通过实例对象调用会出现报错，无法指向具体要调用哪个。因为在底层中，会分别对这四个配置选项进行递归和遍历，通过获取key值进行比较，如果出现相同的那一项，说明已经被命名了，提示报错。如果没有，则允许挂载到组件实例上，因此避免使用命名冲突问题。

#### 5.为什么要使用:key属性？

答：

​	在默认的情况下，从虚拟DOM到渲染真是DOM，会有一个“原地复用”准则，这个准则所带来的好处是降低性能损耗，高效实用。这通常用于循环渲染列表的时候表现的尤为明显，比如要有一个数组[1,2,3,4,5]，对节点遍历数组，会得到基于数组长度的节点数量，但是在底层对这件事进行处理的时候，并不是直接创建基于数组长度的节点数量，而是基于AST解析调用render函数生成虚拟DOM的时候，只创建一个元素节点，但是遍历后的节点是多个，所以渲染的过程就会报错，原因是无法找到这个DOM到底使用的是数组的哪个数据。所以需要在遍历数组的时候，给数据加上对应的标识，然后根据标识来渲染对应的数据，这就达到了创建一个节点，渲染多个数据的好处，降低渲染的开销，提高效率。





​					